[
["index.html", "Get Your Sparkle On 1 Introduction 1.1 pixiedust Design Constraints", " Get Your Sparkle On A Guide to Using the Magic of pixiedust Benjamin Nutter 2017-09-15 1 Introduction .book .book-body .page-wrapper .page-inner section.normal table { width:auto; border-collapse:collapse; border-spacing:2px; } .book .book-body .page-wrapper .page-inner section.normal table td, .book .book-body .page-wrapper .page-inner section.normal table th, .book .book-body .page-wrapper .page-inner section.normal table tr { padding:2; border:0; background-color:#fff; } Tables are a powerful tool for communicating information. They are pervasive in statistical literature in many forms. We see them in text books as references for standard normal probabilities. Some tables organize analysis methods for differing strata in a population. We may even find tables displaying conference schedules. For statisticians, the table is an inevitable tool for conveying the results of any variety of statistical tables. In some cases, we begin to rely on a specific style of table we like for a specific kind of analysis, such as one we might use in exploratory data analysis. Other times, we may need to custom fit a table to a rare or novel analysis worthy of special attention. Creating tables in R is not a new endeavor. Many have attempted it, and many have performed it well. Perhaps most notably, the xtable package has streamlined the process of turning table - like objects into presentation - ready formats. Likewise, knitr’s kable function provides a rapid and reliable method to convert two dimensional grids into aesthetically pleasing tables. Beyond table - like objects, xtable and stargazer packages make conversion of non-table-like objects into tabular representations simple and dependable. In addition to these packages, a multitude of packages have popped up on CRAN to facilitate the creation of tables. These include tableHTML, htmlTable, condformat, and ReporteRs. Each of these has strengths and weaknesses - which we will not enumerate here-and each of these are good packages. So why, then, do we concern ourselves with pixiedust, yet another R package for creating tables? In short, it is because pixiedust offers a simple, consistent interface for fine tuned customization of each and every cell of the table. 1.1 pixiedust Design Constraints The pixiedust package was envisioned with a unique set of constraints. These constraints can be separated into categories involving the data, the user interface, and the output. These constraints guide the development of pixiedust and the philosophy of table customization. 1.1.1 Data Constraints Within any cell of the table The underlying data may be formatted, but not changed. The user must be able to obtain the original object upon request. This means that, no matter what customizations you make to a cell, the data will never be altered until the table is actually printed. In other words, you can eliminate a vast amount of any pre-processing to the data you may have needed to do in the past. Furthermore, if you inadvertently make a dust object from your data, you can restore the data without any loss of information. Consider the following simple example. With pixiedust, we are able to round the first, second, and third rows to two decimal places, and the fourth and fifth rows to four decimal places. library(pixiedust) options(pixiedust_print_method = &quot;html&quot;) set.seed(1) Example &lt;- data.frame(sample_id = 1:5, random = rnorm(5)) %&gt;% dust() %&gt;% sprinkle(rows = 1:3, round = 2) %&gt;% sprinkle(rows = 4:5, round = 4) %&gt;% sprinkle_print_method(&quot;html&quot;) Example %&gt;% print(asis = FALSE) %&gt;% cat() sample_id random 1 -0.63 2 0.18 3 -0.84 4 1.5953 5 0.3295 In most other packages, this type of formatting can’t be done without some preprocessing. Additionally, even though we’ve saved Example as a dust object, the core data is easily retrieved. as.data.frame(Example, sprinkled = FALSE) ## sample_id random ## 1 1 -0.6264538 ## 2 2 0.1836433 ## 3 3 -0.8356286 ## 4 4 1.5952808 ## 5 5 0.3295078 1.1.2 User Interface Constraints The interface must have as few functions as possible. The user should be able to apply as many customizations to a cell as is desired in one call. The user should be able to designate rows and columns by positional reference and named reference. pixiedust comes with two core functions. The dust function converts an object to a tabular structure associated with its formatting choices. The sprinkle function acts on the dust object to change those associations as directed by the user. dust is described in more detail in Section 2.2. Chapter 4 is dedicated to the details of sprinkling. Additionally, there are some variants on sprinkle, namely sprinkle_colnames for changing how column names are printed in the table; sprinkle_table for applying a sprinkle to multiple parts of a table (header, body, and footer); and sprinkle_print_method for changing the print method for a table. Some less commonly used functions that are included with the package are pixieply, a variant of mapply that permits sprinkle to function over a list of dust objects; an as.data.frame method for converting dust objects to data frames; and a print method. Lastly, there are a handful of utility functions for managing table numbering. These can be seen by calling ?pixie_count. The sprinkle function has only four formal arguments. The massive flexibility of pixiedust on such a simple interface is made possible by a flagrant abuse of the ... argument (really, I don’t think ... should ever be treated like it is in pixiedust). This approach allows the user to call as many defined sprinkles as desired without any action being taken on sprinkles that aren’t requested. 1.1.3 Output Constraints The user may choose to output to the console, markdown, HTML, or LaTeX. The interface must be identical for all outputs. When customizations do not apply to an output format, the request will be quietly ignored. When working in Rmarkdown scripts, the output format should be automatically detected, but may be altered by the user. Table numbering should be automatic and handled internally. pixiedust currently supports output to the console, markdown, HTML and LaTeX (PDF), and an engine to output ReporteRs formatted tables is in the works. All of these outputs are controlled using the same interface. This has advantages over packages such as xtable, where some customizations must be written to a specific output, meaning they can’t be transferred from one output format to another. Not all of the customizations are relevant to every format. For example, backgrounds and borders are not supported by console or markdown output. Font families are supported in HTML, but not in LaTex. When a sprinkle is applied that isn’t supported by the format, the request is stored in the dust object, but is quietly ignored at the print request. The advantage to this arrangement is that there are no errors for applying a sprinkle to an unsupported format. The disadvantage is that you may not always realize that your sprinkle won’t show up in your output. Generally, I find that being able to have near-identical tables across multiple formats to outweigh the disadvantage. Since pixiedust is intended to work with Rmarkdown scripts, it is unnecessary to explicitly declare the output format. pixiedust will make use of knitr::opts_knit$get(&quot;rmarkdown.pandoc.to&quot;) to determine the output format for you and make the appropriate adjustments. One last important feature of pixiedust is that, by design, it imposes the minimum intervention possible. If you are using CSS (HTML) templates or LaTeX templates, the settings in those templates should only be superceded by pixiedust when the user requests it explicitly. The tables displayed in this manual have two Cascading Style Sheet (CSS) elements defined: the space between cells is 2 pixels (only applies with border-collapse:separate), and the cell paddign is set to 2 pixels. These settings have been chosen only to help the reader visualize the effect each call has on the table output. Depending on the templates on which your reports are based, the output may differ slightly from what is displayed here. 1.1.4 pixiedust Is Not … While pixiedust is partially motivated by ggplot graphics, it does not purport to be a grammar of any sort, and does not pretend to have a structured philosophy about how to build tables. It simply does what it is told. Additionally, sprinkles should not be considered layers. Any changes made to a cell will simply overwrite previous changes, and will not allow any interaction. A last note of caution before you move on to the documentation: be careful not to over-format your tables. It can be tempting, but the content of the table should speak for itself. Customizations to the tables should merely guide the reader’s eye to the important information. The customizations you make should never scream at the reader. With that, I hope you enjoy using pixiedust as much as I have. If you have questions, problems, frustrations, or suggestions, please submit an issue to the GitHub repository or send me an e-mail: benjamin.nutter@gmail.com "],
["dusting-objects.html", "2 dusting Objects 2.1 Table-wide options 2.2 Anatomy of the dust Object", " 2 dusting Objects .book .book-body .page-wrapper .page-inner section.normal table { width:auto; border-collapse:collapse; border-spacing:2px; } .book .book-body .page-wrapper .page-inner section.normal table td, .book .book-body .page-wrapper .page-inner section.normal table th, .book .book-body .page-wrapper .page-inner section.normal table tr { padding:2; border:0; background-color:#fff; } …no one can fly unless the fairy dust has been blown on him. Fortunately, as we have mentioned, one of [Peter’s] hands was messy with it, and he blew some on each of them, with the most superb results. “Now just wiggle your shoulders this way,” he said, “and let go.” They were all on their beds, and gallant Michael let go first. He did not quite mean to let go, but he did it, and immediately he was borne across the room. “I flewed!” he screamed while still in mid-air. –J.M. Barrie, Peter Pan, Ch. 3, Come, Come Away The primary feature of the pixiedust package is very fine control over each individual cell of a table. This level of control requires maintaining attributes of the output for each cell separately. Tabular structures as we like to view them are not well suited to storing all of these attributes, and so the dust function is used to convert a tabular object into a particular format where we are able to set and alter the display attributes at will. The underlying mechanics of dusting objects aren’t particularly interesting, and for most users, it is sufficient to know that you must apply an initial dusting of pixiedust before you can begin sprinkling specific columns with your desired magic. If you choose to read beyond the table-wide options created during dust, you will learn more about the anatomy of the dust object itself. 2.1 Table-wide options Table wide options are those options that necessarily apply to the entire table. These may include the caption, the justification on the page, the total width of the table, etc. The table-wide options in the dust object are listed below: 2.1.1 caption The caption option determines the text that is placed above the table, and is usually used to provide a summary of the table, or used as a title. When a caption is given, it is numbered automatically by pixiedust. dust(head(mtcars), caption = &quot;The first six lines of mtcars&quot;) Table 2.1: The first six lines of mtcars mpg cyl disp hp drat wt qsec vs am gear carb 21 6 160 110 3.9 2.62 16.46 0 1 4 4 21 6 160 110 3.9 2.875 17.02 0 1 4 4 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 2.1.2 border_collapse Relevant only to HTML tables, the border-collapse option determines if the borders of a table should overlap (or lay on top of) each other. When set to FALSE, a small space will appear between the cell borders. dust(head(mtcars), border_collapse = &#39;collapse&#39;, caption = &quot;A table with &lt;font face = &#39;Courier New&#39;&gt;border_collapse = &#39;collapse&#39;&lt;/font&gt;&quot;) %&gt;% sprinkle(border = &quot;all&quot;) Table 2.2: A table with border_collapse = 'collapse' mpg cyl disp hp drat wt qsec vs am gear carb 21 6 160 110 3.9 2.62 16.46 0 1 4 4 21 6 160 110 3.9 2.875 17.02 0 1 4 4 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 dust(head(mtcars), border_collapse = &#39;separate&#39;, caption = &quot;A table with &lt;font face = &#39;Courier New&#39;&gt;border_collapse = &#39;separate&#39;&lt;/font&gt;&quot;) %&gt;% sprinkle(border = &quot;all&quot;) Table 2.2: A table with border_collapse = 'separate' mpg cyl disp hp drat wt qsec vs am gear carb 21 6 160 110 3.9 2.62 16.46 0 1 4 4 21 6 160 110 3.9 2.875 17.02 0 1 4 4 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 By default, border_collapse = TRUE when a dust object is created. 2.1.3 justify The justify option determines the horizontal placement of the entire table on the page. The option may be given &quot;center&quot;, &quot;left&quot;, or &quot;right&quot;, and defaults to &quot;center&quot;. This setting has no effect on the horizontal alignment of the contents of a table’s cells. The default value for this option is &quot;center&quot;. dust(head(mtcars), justify = &quot;center&quot;, caption = &quot;Center-justified Table&quot;) Table 2.3: Center-justified Table mpg cyl disp hp drat wt qsec vs am gear carb 21 6 160 110 3.9 2.62 16.46 0 1 4 4 21 6 160 110 3.9 2.875 17.02 0 1 4 4 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 dust(head(mtcars), justify = &quot;left&quot;, caption = &quot;Left-justified Table&quot;) Table 2.4: Left-justified Table mpg cyl disp hp drat wt qsec vs am gear carb 21 6 160 110 3.9 2.62 16.46 0 1 4 4 21 6 160 110 3.9 2.875 17.02 0 1 4 4 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 dust(head(mtcars), justify = &quot;right&quot;, caption = &quot;Right-justified Table&quot;) Table 2.5: Right-justified Table mpg cyl disp hp drat wt qsec vs am gear carb 21 6 160 110 3.9 2.62 16.46 0 1 4 4 21 6 160 110 3.9 2.875 17.02 0 1 4 4 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 2.1.4 longtable This option is named after the LATEX package longtable, which is used to break tables with many rows into multiple parts. Each part of the broken table is displayed on a separate page. The default value of the longtable option in pixiedust is FALSE, which retains the table as one unit. If the table is too long to display on a page, you may set the value to TRUE or to an integer value. The behavior of pixiedust will vary slightly, depending on your output type. When longtable = TRUE and the output is LATEX, the table will be divided according to the settings in the LATEX document. For all other formats, the table will be divided such that each table has no more than 25 rows. When longtable is an integer, each section of the table will contain no more than that number of rows, regardless of the format. In all formats, each section of the table will retain the header component of the dust object. The last section of table will have the foot object, and all other sections will have the interfoot object at its end. If the table has a caption, each section of the table will retain the caption and all will have the same number. dust(head(mtcars), longtable = FALSE, caption = &quot;The table caption&quot;) Table 2.6: The table caption mpg cyl disp hp drat wt qsec vs am gear carb 21 6 160 110 3.9 2.62 16.46 0 1 4 4 21 6 160 110 3.9 2.875 17.02 0 1 4 4 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 dust(head(mtcars), longtable = 2, caption = &quot;Notice that the multiple sections of table have the same number&quot;) Table 2.6: Notice that the multiple sections of table have the same number mpg cyl disp hp drat wt qsec vs am gear carb 21 6 160 110 3.9 2.62 16.46 0 1 4 4 21 6 160 110 3.9 2.875 17.02 0 1 4 4 Table 2.6: Notice that the multiple sections of table have the same number mpg cyl disp hp drat wt qsec vs am gear carb 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 Table 2.6: Notice that the multiple sections of table have the same number mpg cyl disp hp drat wt qsec vs am gear carb 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 Use of headers and footers in conjunction with the longtable option is covered in more detail in Chapter 3 2.1.5 label The label option accepts a string that makes a LATEX like label to associate with the table. The label may then be used to make references to the table from elsewhere in the document. These labels work with LATEX output, and with HTML output when bookdown = TRUE. dust(head(mtcars), caption = &quot;A table that has a label&quot;, label = &quot;label-ref&quot;, bookdown = TRUE) Table 2.7: A table that has a label mpg cyl disp hp drat wt qsec vs am gear carb 21 6 160 110 3.9 2.62 16.46 0 1 4 4 21 6 160 110 3.9 2.875 17.02 0 1 4 4 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 When choosing to reference the table above as Table 2.7, you must use the label with a tab: prefix. For the above example, we used tab:label-ref. 2.1.6 float This option impacts only LATEX output. It determines if the table is placed in a floating environment (that is, one that can be moved based on the LATEX engine’s decision of optimal location for the typesetting). By default, this is TRUE. You may set it to FALSE to force the table to appear where it occurs relative to the rest of your document. No example is generated here, as it has no impact on HTML output. 2.1.7 hhline This is another option that impacts only LATEX output. When using colored cell backgrounds in conjunction with cell borders, the default LATEX cell borders can be overwritten by the colored backgrounds. If you wish to have the cell borders and colors, you should set hhline = TRUE. Note, however, that this may restrict you to using solid cell borders, as the dashed borders are not supported by hhline. (Or maybe it’s colored dashed borders. I need to look into that again. But in any case, simplicity is probably your friend here). An illustration of the difference is provided below. dust(head(mtcars), float = FALSE, hhline = FALSE, caption = &quot;A LaTeX Table with \\\\texttt{hhline = FALSE}. Notice that the borders between rows are not evident as requested in the code.&quot;) %&gt;% sprinkle(bg_pattern = c(&quot;#C2A5CF&quot;, &quot;#A6DBA0&quot;)) %&gt;% medley_all_borders() %&gt;% sprinkle_print_method(&quot;latex&quot;) Table 2.8: A LaTeX Table with hhline = FALSE. Notice the borders between rows are not evident as requested in the code. dust(head(mtcars), float = FALSE, hhline = TRUE, caption = &quot;A LaTeX Table with \\\\texttt{hhline = TRUE}. Notice that the borders between rows are readily apparent using the hhline option.&quot;) %&gt;% sprinkle(bg_pattern = c(&quot;#C2A5CF&quot;, &quot;#A6DBA0&quot;)) %&gt;% medley_all_borders() %&gt;% sprinkle_print_method(&quot;latex&quot;) Table 2.9: A LaTeX Table with hhline = FALSE. Notice that the borders between rows are readily apparent using the hhline option.. 2.1.8 bookdown If you are using the bookdown package, it is recommended that you set bookdown = TRUE so that you may make use of bookdown’s referencing syntax, which supports HTML references. Important features to note are: Observe how the table numbering changes between previous tables and the table below. We are unable to make a reference the table below as an HTML table (though we could still reference a LaTeX table). dust(head(mtcars), caption = &quot;A table with the &lt;font face = &#39;Courier New&#39;&gt;bookdown&lt;/font&gt; option turned off.&quot;, label = &quot;label-ref&quot;, bookdown = FALSE) Table 424: A table with the bookdown option turned off. mpg cyl disp hp drat wt qsec vs am gear carb 21 6 160 110 3.9 2.62 16.46 0 1 4 4 21 6 160 110 3.9 2.875 17.02 0 1 4 4 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 By default, pixiedust uses bookdown = FALSE. However, this book was written using bookdown = TRUE using the options described in section @ref(#dust-setting-options-globally). 2.1.9 Setting Options Globally Most of the options discussed above may be set as a global option. Doing so will reduce the code required to apply these settings to each table. The code below shows an example of how to set all of the available options to the default values. options(pixie_float = TRUE, pixie_longtable = FALSE, pixie_hhline = FALSE, pixie_bookdown = FALSE) 2.2 Anatomy of the dust Object Now let’s get into the nitty-gritty and take a look at what dust is doing to your objects. To start, let’s first recognize that dust is dependent of having tabular data. The first thing it will try to do is force any object it receives into a two-dimensional table. If, for example, you give it an lm object, dust will attempt to normalize the object to a data frame via the tidy methods in the broom package. Once the object has been coereced to a data frame, dust will break the table into two parts: the header, and the body. A footer may be added to objects that have a glance method when glance_foot = TRUE, otherwise, it is assumed there is no footer. It is always assumed there is no interfoot; if this feature is desired it must be added later using the redust function. Details on these features are discussed more in Chapter 3. The key feature of pixiedust is its ability to offer fine control over each and every cell of the table. To accomplish this, it is necessary to build a reference table that maps each cell to it’s attributes. Let us consider the table below: example &lt;- data.frame(x1 = c(&quot;r1, c1&quot;, &quot;r2, c1&quot;, &quot;r3, c1&quot;), x2 = c(&quot;r1, c2&quot;, &quot;r2, c2&quot;, &quot;r3, c2&quot;), x3 = c(&quot;r1, c3&quot;, &quot;r2, c3&quot;, &quot;r3, c3&quot;), stringsAsFactors = FALSE) example ## x1 x2 x3 ## 1 r1, c1 r1, c2 r1, c3 ## 2 r2, c1 r2, c2 r2, c3 ## 3 r3, c1 r3, c2 r3, c3 The layout of the body of the table is formed in the body component of the dust object after reshaping the data frame as follows: example %&gt;% mutate(row = 1:n()) %&gt;% gather_(&quot;col&quot;, &quot;value&quot;, names(example)[!names(example) %in% &quot;row&quot;]) %&gt;% mutate_(col_name = ~factor(col, colnames(example)), col = ~as.numeric(col_name), col_name = ~as.character(col_name), value = ~as.character(value)) ## row col value col_name ## 1 1 1 r1, c1 x1 ## 2 2 1 r2, c1 x1 ## 3 3 1 r3, c1 x1 ## 4 1 2 r1, c2 x2 ## 5 2 2 r2, c2 x2 ## 6 3 2 r3, c2 x2 ## 7 1 3 r1, c3 x3 ## 8 2 3 r2, c3 x3 ## 9 3 3 r3, c3 x3 Notice that for a simple 3x3 table, a data frame of nine rows is required to begin to capture the cell attributes, which we have not yet displayed. An additional three cells are required in the head object when the header has only one row. In general, the cell attributes of each table are captured in a data frame with \\(r \\times c\\) rows where \\(r\\) is the number of rows in the table, and \\(c\\) is the number of columns. Let’s take a look at the body component of the dusted example table. tbl &lt;- dust(example) tbl[[&quot;body&quot;]] ## row col value col_name fn round bold italic halign valign bg ## 1 1 1 r1, c1 x1 NA FALSE FALSE ## 2 2 1 r2, c1 x1 NA FALSE FALSE ## 3 3 1 r3, c1 x1 NA FALSE FALSE ## 4 1 2 r1, c2 x2 NA FALSE FALSE ## 5 2 2 r2, c2 x2 NA FALSE FALSE ## 6 3 2 r3, c2 x2 NA FALSE FALSE ## 7 1 3 r1, c3 x3 NA FALSE FALSE ## 8 2 3 r2, c3 x3 NA FALSE FALSE ## 9 3 3 r3, c3 x3 NA FALSE FALSE ## font_family font_color font_size font_size_units left_border ## 1 ## 2 ## 3 ## 4 ## 5 ## 6 ## 7 ## 8 ## 9 ## right_border top_border bottom_border height height_units width ## 1 ## 2 ## 3 ## 4 ## 5 ## 6 ## 7 ## 8 ## 9 ## width_units replace rotate_degree sanitize sanitize_args pad rowspan ## 1 NA FALSE 1 ## 2 NA FALSE 1 ## 3 NA FALSE 1 ## 4 NA FALSE 1 ## 5 NA FALSE 1 ## 6 NA FALSE 1 ## 7 NA FALSE 1 ## 8 NA FALSE 1 ## 9 NA FALSE 1 ## colspan na_string html_row html_col merge_rowval merge_colval merge ## 1 1 NA 1 1 1 1 FALSE ## 2 1 NA 2 1 2 1 FALSE ## 3 1 NA 3 1 3 1 FALSE ## 4 1 NA 1 2 1 2 FALSE ## 5 1 NA 2 2 2 2 FALSE ## 6 1 NA 3 2 3 2 FALSE ## 7 1 NA 1 3 1 3 FALSE ## 8 1 NA 2 3 2 3 FALSE ## 9 1 NA 3 3 3 3 FALSE ## col_class ## 1 character ## 2 character ## 3 character ## 4 character ## 5 character ## 6 character ## 7 character ## 8 character ## 9 character We take note that the body component is a data frame with 9 rows and 37 columns. This is a much larger data frame than the initial object, which accounts for both the bloated size of dust objects (example is 1,424 bytes while tbl is 18,544 bytes). It also accounts for the slowness of pixiedust when compared to other table generating functions like knitr::kable and xtable. pixiedust runs in about 20 milliseconds to process example without any sprinkles, while it takes knitr::kable about 1 millisecond. These speed differences are indiscernable to humans for one table at a time, but if you will be processing hundreds or thousands of tables that need to be completed quickly (such as in a web application), pixiedust may not be your best option. But for individual tables that require fine-tuned formatting, it is a good compromise of control and ease of use. "],
["chapter-header-footer.html", "3 Headers and Footers", " 3 Headers and Footers "],
["chapter-sprinkles.html", "4 Sprinkling 4.1 Table-valued Sprinkles 4.2 Cell-valued Sprinkles 4.3 Examples", " 4 Sprinkling .book .book-body .page-wrapper .page-inner section.normal table { width:auto; border-collapse:collapse; border-spacing:2px; } .book .book-body .page-wrapper .page-inner section.normal table td, .book .book-body .page-wrapper .page-inner section.normal table th, .book .book-body .page-wrapper .page-inner section.normal table tr { padding:2; border:0; background-color:#fff; } The dust function structures the table with the most basic preparations for printing. Customizations to the table are added by sprinkling your table with additional pixiedust. The full list of available sprinkles is provided in one of pixiedust’s vignettes. some of the sprinkles apply to the entire table, and some will apply only to selected cells. 4.1 Table-valued Sprinkles While dust offers a mechanism for applying certain attributes to the entire table, it is also permissible to assign these attributes through sprinkles. Whether the attribute is set using dust or sprinkle, the effect is the same. Table-valued sprinkles have the same name as the arguments described in Section 2.1. We won’t bother exploring all of these sprinkles here, but will provide a single example with the caption sprinkle, shown in Table 4.1. dust(head(mtcars)) %&gt;% sprinkle(caption = &quot;This caption was defined in the sprinkle function&quot;, label = &quot;sprinkle-caption&quot;) Table 4.1: This caption was defined in the sprinkle function mpg cyl disp hp drat wt qsec vs am gear carb 21 6 160 110 3.9 2.62 16.46 0 1 4 4 21 6 160 110 3.9 2.875 17.02 0 1 4 4 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 The full list of table-valued sprinkles is given in Table 4.2. ## Warning in read.dcf(file.path(p, &quot;DESCRIPTION&quot;), c(&quot;Package&quot;, &quot;Version&quot;)): ## cannot open compressed file &#39;C:\\Users\\Nutter\\Documents\\GitHub\\pixiedust/ ## DESCRIPTION&#39;, probable reason &#39;No such file or directory&#39; Table 4.2: Table Valued Sprinkles sprinkle bookdown border_collapse caption float hhline justify label longtable tabcolsep 4.2 Cell-valued Sprinkles The primary feature of pixiedust is the ability to fine-tune each individual cell in a table. Cell-specific customizations in other packages often require indexing changes in long function calls with multiple arguments that can make it difficult to easily relate the customization to the targeted cells. pixiedust provides a wide array of customizations, including background colors, borders, bold and italic text, fonts, and font colors. The following sections will elaborate on how to apply sprinkles to a table. Section 4.3 provides a gallery of each of the sprinkles and their affect on a table. 4.2.1 Cell Selection 4.2.1.1 Cell Selection by Index The first step in applying sprinkles is identifying the cells in the table you wish to modify. Tabular data lends itself nicely to a two dimensional coordinate system. pixiedust relies on standard matrix indexing notation where rows are indexed sequentially starting with one at the top row. Columns are indexed sequentially starting with one at the left. When referencing cell coordinates, keep in mind that each part of the table is indexed separately. This means that the body of the table has a [1,1] position, as does the head, the foot, and the interfoot. Sprinkles applied to position [1,1] of the head of a table will have no effect on the [1,1] position of the body of the table. Compare Tables 4.3 and 4.4. dust(head(mtcars), caption = &quot;Cell Indexed Sprinkle on the Header Only&quot;, label = &quot;sprinkle-head&quot;) %&gt;% medley_bw() %&gt;% sprinkle(rows = 1, cols = 1, font_color = &quot;red&quot;, part = &quot;head&quot;) Table 4.3: Cell Indexed Sprinkle on the Header Only mpg cyl disp hp drat wt qsec vs am gear carb 21 6 160 110 3.9 2.62 16.46 0 1 4 4 21 6 160 110 3.9 2.875 17.02 0 1 4 4 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 dust(head(mtcars), caption = &quot;Cell Indexed Sprinkle on the Body Only&quot;, label = &quot;sprinkle-body&quot;) %&gt;% medley_bw() %&gt;% sprinkle(rows = 1, cols = 1, font_color = &quot;red&quot;, part = &quot;body&quot;) Table 4.4: Cell Indexed Sprinkle on the Body Only mpg cyl disp hp drat wt qsec vs am gear carb 21 6 160 110 3.9 2.62 16.46 0 1 4 4 21 6 160 110 3.9 2.875 17.02 0 1 4 4 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 When multiple cells are to be modified, the default behavior is to apply the sprinkle to the intersection of rows and columns designated. This makes sprinkle pretty greedy in how it assigns modifications; making identical modifications to disjointed sections of code is not its default behavior. Table 4.5 applies a purple background to the four cells in the top left corner. Compare this with Table 4.6, where the sprinkling is performed in all four corners. dust(head(mtcars), caption = &quot;Sprinkling applied to the four cells in the top left corner&quot;, label = &quot;sprinkle-region1&quot;) %&gt;% sprinkle(rows = 1:2, cols = 1:2, bg = palette[3]) %&gt;% medley_bw() Table 4.5: Sprinkling applied to the four cells in the top left corner mpg cyl disp hp drat wt qsec vs am gear carb 21 6 160 110 3.9 2.62 16.46 0 1 4 4 21 6 160 110 3.9 2.875 17.02 0 1 4 4 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 dust(head(mtcars), caption = &quot;Sprinkling applied to the four cells in each corner.&quot;, label = &quot;sprinkle-region2&quot;) %&gt;% sprinkle(rows = c(1:2, 5:6), cols = c(1:2, 10:11), bg = palette[3]) %&gt;% medley_bw() Table 4.6: Sprinkling applied to the four cells in each corner. mpg cyl disp hp drat wt qsec vs am gear carb 21 6 160 110 3.9 2.62 16.46 0 1 4 4 21 6 160 110 3.9 2.875 17.02 0 1 4 4 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 The behavior of sprinkling in Table 4.6 can be elaborated using expand.grid. The call shown below identifies all of the cell coordinates where the sprinkle was applied. expand.grid(rows = c(1:2, 5:6), cols = c(1:2, 10:11)) ## rows cols ## 1 1 1 ## 2 2 1 ## 3 5 1 ## 4 6 1 ## 5 1 2 ## 6 2 2 ## 7 5 2 ## 8 6 2 ## 9 1 10 ## 10 2 10 ## 11 5 10 ## 12 6 10 ## 13 1 11 ## 14 2 11 ## 15 5 11 ## 16 6 11 If the table we desired were to have purple cells only in the top-left and lower-right corners, we would have to apply two sprinkles, as shown for Table 4.7 dust(head(mtcars), caption = &quot;Sprinkling applied to the four cells in each corner.&quot;, label = &quot;sprinkle-region3&quot;) %&gt;% sprinkle(rows = c(1:2), cols = c(1:2), bg = palette[3]) %&gt;% sprinkle(rows = c(5:6), cols = c(10:11), bg = palette[3]) %&gt;% medley_bw() Table 4.7: Sprinkling applied to the four cells in each corner. mpg cyl disp hp drat wt qsec vs am gear carb 21 6 160 110 3.9 2.62 16.46 0 1 4 4 21 6 160 110 3.9 2.875 17.02 0 1 4 4 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 4.2.1.2 Cell Selection by Column Name Sprinkling your table by index may be intuitive, but it isn’t entirely reproducible. Fortunately, the cols argument in sprinkle also accepts character vectors. Using column names has a number of advantages, such as improving readability of the code and simplifying programmatic use. It also means that you will get the same results even if new columns are introduced to the table after it is generated. Compare Table 4.8 with Table 4.5 and the code to generate these tables. dust(head(mtcars), caption = &quot;Sprinkling applied to the four cells in the top left corner&quot;, label = &quot;sprinkle-colname1&quot;) %&gt;% sprinkle(rows = 1:2, cols = c(&quot;mpg&quot;, &quot;cyl&quot;), bg = palette[3]) %&gt;% medley_bw() Table 4.8: Sprinkling applied to the four cells in the top left corner mpg cyl disp hp drat wt qsec vs am gear carb 21 6 160 110 3.9 2.62 16.46 0 1 4 4 21 6 160 110 3.9 2.875 17.02 0 1 4 4 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 % --> % --> % --> % --> % --> 4.2.2 Sprinkle Cells by Fixed Cell Position 4.2.3 Recycling Sprinkles Over Cells 4.3 Examples "],
["colors.html", "5 Colors 5.1 Named Colors 5.2 RGB Colors 5.3 HEX Colors 5.4 Transparency", " 5 Colors .book .book-body .page-wrapper .page-inner section.normal table { width:auto; border-collapse:collapse; border-spacing:2px; } .book .book-body .page-wrapper .page-inner section.normal table td, .book .book-body .page-wrapper .page-inner section.normal table th, .book .book-body .page-wrapper .page-inner section.normal table tr { padding:2; border:0; background-color:#fff; } Colors may be used for cell borders and backgrounds. pixiedust works hard to make it easy to use colors while also giving a great deal of flexibility. 5.1 Named Colors Designating a color can be a simple as providing a name, so long as you know the valid color names. Fortunately, pixiedust recognizes all of the DVIPS color names recognized by R itself. The full list of colors can be seen by running colors() at the command line. We show the first 30 colors here: head(colors(), 30) ## [1] &quot;white&quot; &quot;aliceblue&quot; &quot;antiquewhite&quot; &quot;antiquewhite1&quot; ## [5] &quot;antiquewhite2&quot; &quot;antiquewhite3&quot; &quot;antiquewhite4&quot; &quot;aquamarine&quot; ## [9] &quot;aquamarine1&quot; &quot;aquamarine2&quot; &quot;aquamarine3&quot; &quot;aquamarine4&quot; ## [13] &quot;azure&quot; &quot;azure1&quot; &quot;azure2&quot; &quot;azure3&quot; ## [17] &quot;azure4&quot; &quot;beige&quot; &quot;bisque&quot; &quot;bisque1&quot; ## [21] &quot;bisque2&quot; &quot;bisque3&quot; &quot;bisque4&quot; &quot;black&quot; ## [25] &quot;blanchedalmond&quot; &quot;blue&quot; &quot;blue1&quot; &quot;blue2&quot; ## [29] &quot;blue3&quot; &quot;blue4&quot; A good resource for seeing what these colors looks like is http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf pixiedust also recognizes an additional name, &quot;transparent&quot;, for when you wish to remove a color that may have already been applied. In the example below, we’ll add a background color to the non-intercept rows in the model summary that are statistically significant. fit &lt;- lm(mpg ~ qsec + factor(gear) + wt, data = mtcars) dust(fit) %&gt;% sprinkle(rows = c(2, 5), bg = &quot;lightgreen&quot;) term estimate std.error statistic p.value (Intercept) 16.9629385 7.1503505 2.3723227 0.025061 qsec 0.9531255 0.3481294 2.7378486 0.0108106 factor(gear)4 1.4053374 1.3340693 1.0534216 0.3014842 factor(gear)5 1.4936744 1.8064949 0.8268357 0.4155779 wt -4.5519623 0.6539171 -6.9610696 2e-07 5.2 RGB Colors The colors() named in R offer you 657 unique colors. But colors may also be specified as an RGB character string of the format &quot;rgb(RRR, GGG, BBB)&quot; where RRR, GGG, and BBB are integers between 0 and 255. With 256 values of each of those three spots, that provides you with a total of 16,777,216 distinct colors available for use. We can replicate the table from the previous example using the &quot;rgb()&quot; color specification as follows: fit &lt;- lm(mpg ~ qsec + factor(gear) + wt, data = mtcars) dust(fit) %&gt;% sprinkle(rows = c(2, 5), bg = &quot;rgb(144, 238, 144)&quot;) term estimate std.error statistic p.value (Intercept) 16.9629385 7.1503505 2.3723227 0.025061 qsec 0.9531255 0.3481294 2.7378486 0.0108106 factor(gear)4 1.4053374 1.3340693 1.0534216 0.3014842 factor(gear)5 1.4936744 1.8064949 0.8268357 0.4155779 wt -4.5519623 0.6539171 -6.9610696 2e-07 5.3 HEX Colors Hexadecimal color codes are another common way to define colors, especially in HTML formats. RColorBrewer is a package that returns color codes in hexadecimal format. To specify a hexidecimal color in pixiedust, use a character string in &quot;#RRGGBB&quot; format where RR, GG, and BB are hexidecimal values between 00 and FF. Our previous example is replicated again using hex codes as fit &lt;- lm(mpg ~ qsec + factor(gear) + wt, data = mtcars) dust(fit) %&gt;% sprinkle(rows = c(2, 5), bg = &quot;#90EE90&quot;) term estimate std.error statistic p.value (Intercept) 16.9629385 7.1503505 2.3723227 0.025061 qsec 0.9531255 0.3481294 2.7378486 0.0108106 factor(gear)4 1.4053374 1.3340693 1.0534216 0.3014842 factor(gear)5 1.4936744 1.8064949 0.8268357 0.4155779 wt -4.5519623 0.6539171 -6.9610696 2e-07 5.4 Transparency pixiedust supports color transparency for HTML tables only. To use transparency, define your colors as &quot;rgba(RRR, GGG, BBB, AA)&quot; where AA is a value between 0 (fully transparent) and 1 (fully opaque). Hexidecimal colors are specified by &quot;#RRGGBBAA&quot; where AA is a hexidecimal number from 00 (fully transparent) and FF (fully opaque). We will do a variation of the previous example where we shade the statistically significant rows in black, and use transparency to ensure the text is still visible (it’s a silly thing to do, since we could just use gray, but it’s a good way to illustrate the point) fit &lt;- lm(mpg ~ qsec + factor(gear) + wt, data = mtcars) dust(fit) %&gt;% sprinkle(rows = 2, bg = &quot;#0000003F&quot;) %&gt;% sprinkle(rows = 4, bg = &quot;rgba(00,00,00,.25)&quot;) term estimate std.error statistic p.value (Intercept) 16.9629385 7.1503505 2.3723227 0.025061 qsec 0.9531255 0.3481294 2.7378486 0.0108106 factor(gear)4 1.4053374 1.3340693 1.0534216 0.3014842 factor(gear)5 1.4936744 1.8064949 0.8268357 0.4155779 wt -4.5519623 0.6539171 -6.9610696 2e-07 "],
["latex-configuration.html", "6 LaTeX Configuration", " 6 LaTeX Configuration In order to produce LaTeX output, you will need to ensure the following packages are installed and in use in your document. amssymb arydshln caption graphicx hhline longtable multirow xcolor (with the dvipsnames, and table options.) If you are using an Rmarkdown document, I recommend including the following text in your YAML front matter. The new command defined in this block is necessary if you wish to use dashed borders. If you don’t intend to use dashed borders, it is usually harmless to leave the new command definition in your front matter. There are, however, certain circumstances where this definition cause LaTeX rendering to fail. Unfortunately, I haven’t quite narrowed down what the boundaries of those circumstances are. If you aren’t using dashed borders and are getting odd messages, you may try removing the last three lines from this block to make it work. header-includes: - \\usepackage{amssymb} - \\usepackage{arydshln} - \\usepackage{caption} - \\usepackage{graphicx} - \\usepackage{hhline} - \\usepackage{longtable} - \\usepackage{multirow} - \\usepackage[dvipsnames,table]{xcolor} - \\makeatletter - \\newcommand*\\vdashline{\\rotatebox[origin=c]{90}{\\$\\dabar@\\dabar@\\dabar@\\$}} - \\makeatother If you are using Sweave, or just need the straight LaTeX code without the YAML format, here’s a convenient place from which to copy it. \\usepackage{amssymb} \\usepackage{arydshln} \\usepackage{caption} \\usepackage{graphicx} \\usepackage{hhline} \\usepackage{longtable} \\usepackage{multirow} \\usepackage[dvipsnames,table]{xcolor} \\makeatletter \\newcommand*\\vdashline{\\rotatebox[origin=c]{90}{\\$\\dabar@\\dabar@\\dabar@\\$}} \\makeatother "],
["medleys.html", "7 Medleys 7.1 Constructing a Medley", " 7 Medleys .book .book-body .page-wrapper .page-inner section.normal table { width:auto; border-collapse:collapse; border-spacing:2px; } .book .book-body .page-wrapper .page-inner section.normal table td, .book .book-body .page-wrapper .page-inner section.normal table th, .book .book-body .page-wrapper .page-inner section.normal table tr { padding:2; border:0; background-color:#fff; } It is a common desire to have a standard layout and general appearance for all tables in a document. It may also be that your organization or the journal you are submitting to has specific expectations for what a table should look like. Be design, pixiedust is intended not to interfere with any templates that may be defined in a LaTeX or HTML document (i.e., using custom CSS). However, if you are not familiar with LaTeX or CSS styling, it can be daunting to generate your templates. Medleys offer an alternative solution that allows you to write a function to produce your desired look. 7.1 Constructing a Medley Strictly speaking, a medley is nothing more than a function that takes a dust object as an argument, and returns a dust object. The default styling for a table may look as plain as: head(mtcars) %&gt;% dust(caption = &quot;A table with minimal formatting&quot;, label = &quot;medley-plain&quot;) Table 7.1: A table with minimal formatting mpg cyl disp hp drat wt qsec vs am gear carb 21 6 160 110 3.9 2.62 16.46 0 1 4 4 21 6 160 110 3.9 2.875 17.02 0 1 4 4 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 Suppose I desire that all of my tables have a border above the header and a border at the bottom of the table. I can create a medley to apply these two borders by defining a function. medley_mine &lt;- function(object) { last_row &lt;- max(object$body$row) object %&gt;% sprinkle(rows = 1, border = &quot;top&quot;, part = &quot;head&quot;) %&gt;% sprinkle(rows = last_row, border = &quot;bottom&quot;) } head(mtcars) %&gt;% dust(caption = &quot;A table with a little formatting&quot;, label = &quot;medley-a-bit-more&quot;) %&gt;% medley_mine() Table 7.2: A table with a little formatting mpg cyl disp hp drat wt qsec vs am gear carb 21 6 160 110 3.9 2.62 16.46 0 1 4 4 21 6 160 110 3.9 2.875 17.02 0 1 4 4 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 It is possible to extend the medley to any extent. The next segment of code adds row striping in my favorite color scheme: medley_mine &lt;- function(object) { last_row &lt;- max(object$body$row) object %&gt;% sprinkle(rows = 1, border = &quot;top&quot;, part = &quot;head&quot;) %&gt;% sprinkle(rows = last_row, border = &quot;bottom&quot;) %&gt;% sprinkle(bg_pattern = palette[c(3, 7)]) } head(mtcars) %&gt;% dust(caption = &quot;A table with a little formatting and striping&quot;, label = &quot;medley-with-stripe&quot;) %&gt;% medley_mine() Table 7.3: A table with a little formatting and striping mpg cyl disp hp drat wt qsec vs am gear carb 21 6 160 110 3.9 2.62 16.46 0 1 4 4 21 6 160 110 3.9 2.875 17.02 0 1 4 4 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 When desired, you may even add additional arguments that let you add or remove features as desired. medley_mine &lt;- function(object, stripe = TRUE) { last_row &lt;- max(object$body$row) object &lt;- object %&gt;% sprinkle(rows = 1, border = &quot;top&quot;, part = &quot;head&quot;) %&gt;% sprinkle(rows = last_row, border = &quot;bottom&quot;) if (stripe) { object %&gt;% sprinkle(bg_pattern = palette[c(3, 7)]) } else { object } } head(mtcars) %&gt;% dust(caption = &quot;A table with a little formatting and optional striping turned off&quot;, label = &quot;medley-stripe-off&quot;) %&gt;% medley_mine(stripe = FALSE) Table 7.4: A table with a little formatting and optional striping turned off mpg cyl disp hp drat wt qsec vs am gear carb 21 6 160 110 3.9 2.62 16.46 0 1 4 4 21 6 160 110 3.9 2.875 17.02 0 1 4 4 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 head(mtcars) %&gt;% dust(caption = &quot;A table with a little formatting and optional striping turned on&quot;, label = &quot;medley-stripe-on&quot;) %&gt;% medley_mine(stripe = TRUE) Table 7.5: A table with a little formatting and optional striping turned on mpg cyl disp hp drat wt qsec vs am gear carb 21 6 160 110 3.9 2.62 16.46 0 1 4 4 21 6 160 110 3.9 2.875 17.02 0 1 4 4 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 "],
["table-numbering-and-referencing.html", "8 Table Numbering and Referencing", " 8 Table Numbering and Referencing "],
["working-with-lists-of-tables.html", "9 Working with Lists of Tables", " 9 Working with Lists of Tables "],
["using-tables-effectively.html", "10 Using Tables Effectively 10.1 Guiding Principles 10.2 Row Discrimination 10.3 Drawing Attention to Results 10.4 Grouping 10.5 Sectioning", " 10 Using Tables Effectively .book .book-body .page-wrapper .page-inner section.normal table { width:auto; border-collapse:collapse; border-spacing:2px; } .book .book-body .page-wrapper .page-inner section.normal table td, .book .book-body .page-wrapper .page-inner section.normal table th, .book .book-body .page-wrapper .page-inner section.normal table tr { padding:2; border:0; background-color:#fff; } Tables are a tool for organizing, structuring, and communicating nuances about data. As with most tools, they have strengths and weaknesses. They may also be used effectively or ineffectively. The purpose of this chapter is to show strategies for various tabular needs, and how to implement them using pixiedust. Some of the more tempting strategies that ought to be avoided will also be discussed. Throughout this chapter, the focus will remain on maximizing the communicative power of your tables. The goal of any table is to convey the desired message accurately, efficiently, and without imposing unnecessary distraction. 10.1 Guiding Principles When developing tables for your reports and presentations, I recommend you consider the following guiding principles: Avoid trying to use tables the way you would a graph. If your table requires a legend, it’s too complicated. Use a graph instead. Background colors should only be used for row or group discrimination (with very rare exceptions). Subtlety is a virtue. When using color (backgrounds, fonts, or borders), try to limit yourself to two colors. 10.2 Row Discrimination As tables grow wider, there is a greater risk that the reader will have difficulty relating elements on one side of the table to the elements on the other side of the table. Consider the display in Table 10.1. Owing to the cell padding, with little effort we can determine that the Duster 360 has 3 gears. Regardless, we may use a few different strategies to reduce the visual burden for the reader to correctly associate data with the correct vehicle. head(mtcars, 12) %&gt;% dust(label = &quot;basic-example&quot;, caption = &quot;A table without aids for discriminating lines&quot;, keep_rownames = TRUE) Table 10.1: A table without aids for discriminating lines .rownames mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21 6 160 110 3.9 2.62 16.46 0 1 4 4 Mazda RX4 Wag 21 6 160 110 3.9 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 Valiant 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 Duster 360 14.3 8 360 245 3.21 3.57 15.84 0 0 3 4 Merc 240D 24.4 4 146.7 62 3.69 3.19 20 1 0 4 2 Merc 230 22.8 4 140.8 95 3.92 3.15 22.9 1 0 4 2 Merc 280 19.2 6 167.6 123 3.92 3.44 18.3 1 0 4 4 Merc 280C 17.8 6 167.6 123 3.92 3.44 18.9 1 0 4 4 Merc 450SE 16.4 8 275.8 180 3.07 4.07 17.4 0 0 3 3 10.2.1 Striping Currently, the most popular discrimination strategy is striping. Striping alternates colors from one row to another. This creates a visual barrier between rows to prevent the eye from drifting off of the desired row. head(mtcars, 12) %&gt;% dust(label = &quot;striped-example&quot;, caption = &quot;A table with &lt;i&gt;Zebra Striping&lt;/i&gt;&quot;, keep_rownames = TRUE) %&gt;% sprinkle(bg_pattern_by = &quot;rows&quot;) Table 10.2: A table with Zebra Striping .rownames mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21 6 160 110 3.9 2.62 16.46 0 1 4 4 Mazda RX4 Wag 21 6 160 110 3.9 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 Valiant 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 Duster 360 14.3 8 360 245 3.21 3.57 15.84 0 0 3 4 Merc 240D 24.4 4 146.7 62 3.69 3.19 20 1 0 4 2 Merc 230 22.8 4 140.8 95 3.92 3.15 22.9 1 0 4 2 Merc 280 19.2 6 167.6 123 3.92 3.44 18.3 1 0 4 4 Merc 280C 17.8 6 167.6 123 3.92 3.44 18.9 1 0 4 4 Merc 450SE 16.4 8 275.8 180 3.07 4.07 17.4 0 0 3 3 The striping strategy in Table 10.2 is great for on-screen displays. It even looks great when it is initially printed on paper. Depending on your color selection, however, two things could happen if a printed copy is photocopied: If the striping colors are dark, the photocopy could generate result in background colors that are too dark for the text to be seen. If the striping colors are light, the photocopy may not show the striping at all. For these reasons, it is advisable to use light colors in the striping backgrounds (preferably white and gray; or at least one white). If there is reason to believe that your output will be printed and/or photocopied, it may be better not to rely on striping and to use some other strategy. 10.2.2 Horizontal Borders For printed pages, using horizontal borders can be an effective way to assist with row discrimination. This only requires printing a border at the bottom of each row. head(mtcars, 12) %&gt;% dust(label = &quot;plain-lined-example&quot;, caption = &quot;A table with solid horizontal lines&quot;, keep_rownames = TRUE) %&gt;% sprinkle(border = &quot;bottom&quot;) Table 10.3: A table with solid horizontal lines .rownames mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21 6 160 110 3.9 2.62 16.46 0 1 4 4 Mazda RX4 Wag 21 6 160 110 3.9 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 Valiant 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 Duster 360 14.3 8 360 245 3.21 3.57 15.84 0 0 3 4 Merc 240D 24.4 4 146.7 62 3.69 3.19 20 1 0 4 2 Merc 230 22.8 4 140.8 95 3.92 3.15 22.9 1 0 4 2 Merc 280 19.2 6 167.6 123 3.92 3.44 18.3 1 0 4 4 Merc 280C 17.8 6 167.6 123 3.92 3.44 18.9 1 0 4 4 Merc 450SE 16.4 8 275.8 180 3.07 4.07 17.4 0 0 3 3 An alternative look may be to use a lighter color, as in Table 10.4. However, the lighter color may fail to appear on some printed documents, and has a greater risk of not appearing on photocopies. If photocopies are a reasonable possiblity for the future of your output, the solid black lines are your safest bet. head(mtcars, 12) %&gt;% dust(label = &quot;gray-line-example&quot;, caption = &quot;A table with gray horizontal lines&quot;, keep_rownames = TRUE) %&gt;% sprinkle(border = &quot;bottom&quot;, border_color = &quot;#DDDDDD&quot;) Table 10.4: A table with gray horizontal lines .rownames mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21 6 160 110 3.9 2.62 16.46 0 1 4 4 Mazda RX4 Wag 21 6 160 110 3.9 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 Valiant 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 Duster 360 14.3 8 360 245 3.21 3.57 15.84 0 0 3 4 Merc 240D 24.4 4 146.7 62 3.69 3.19 20 1 0 4 2 Merc 230 22.8 4 140.8 95 3.92 3.15 22.9 1 0 4 2 Merc 280 19.2 6 167.6 123 3.92 3.44 18.3 1 0 4 4 Merc 280C 17.8 6 167.6 123 3.92 3.44 18.9 1 0 4 4 Merc 450SE 16.4 8 275.8 180 3.07 4.07 17.4 0 0 3 3 10.3 Drawing Attention to Results There are occasions when tables display a great deal of information, but there may be a few on which you want the reader to focus. In these situations, the most effective strategy is to use a bold or italic typeface for the targeted results. These typefaces render well on screen and on paper, and do not suffer from the disadvantages of printing and/or photocopying. In Table 10.5, the regression coefficients that are significant at the 5% level are printed in bold font. fit &lt;- lm(mpg ~ wt + factor(am) + hp + factor(gear), data = mtcars) dust(fit, label = &quot;bold-result-model&quot;, caption = &quot;Statistically Significant Results in Bold&quot;) %&gt;% medley_model() %&gt;% medley_bw() %&gt;% sprinkle(# rows = quote(p.value &lt;= 0.05), # Not yet supported rows = c(1, 2, 4), bold = TRUE) Table 10.5: Statistically Significant Results in Bold term estimate std.error statistic p.value (Intercept) 33.76 2.86 11.82 wt -2.8 1 -2.8 0.01 factor(am)1 1.69 1.84 0.92 0.37 hp -0.04 0.01 -2.91 0.007 factor(gear)4 0.41 1.64 0.25 0.81 factor(gear)5 0.8 2.21 0.36 0.72 This strategy also works well with striping to maintain row discrimination. fit &lt;- lm(mpg ~ wt + factor(am) + hp + factor(gear), data = mtcars) dust(fit, label = &quot;bold-result-stripe&quot;, caption = &quot;Statistically Significant Results in Bold&quot;) %&gt;% medley_model() %&gt;% medley_bw() %&gt;% sprinkle(# rows = quote(p.value &lt;= 0.05), # not yet supported rows = c(1, 2, 4), bold = TRUE) %&gt;% sprinkle(bg_pattern_by = &quot;rows&quot;) Table 10.6: Statistically Significant Results in Bold term estimate std.error statistic p.value (Intercept) 33.76 2.86 11.82 wt -2.8 1 -2.8 0.01 factor(am)1 1.69 1.84 0.92 0.37 hp -0.04 0.01 -2.91 0.007 factor(gear)4 0.41 1.64 0.25 0.81 factor(gear)5 0.8 2.21 0.36 0.72 Alternatively, depending on the format, you may try using colored text to draw attention to results, as in Table 10.7. fit &lt;- lm(mpg ~ wt + factor(am) + hp + factor(gear), data = mtcars) dust(fit, label = &quot;bold-result-red&quot;, caption = &quot;Statistically Significant Results in Red&quot;) %&gt;% medley_model() %&gt;% medley_bw() %&gt;% sprinkle(# rows = quote(p.value &lt;= 0.05), # not yet supported rows = c(1, 2, 4), font_color = &quot;red&quot;) %&gt;% sprinkle(bg_pattern_by = &quot;rows&quot;) Table 10.7: Statistically Significant Results in Red term estimate std.error statistic p.value (Intercept) 33.76 2.86 11.82 wt -2.8 1 -2.8 0.01 factor(am)1 1.69 1.84 0.92 0.37 hp -0.04 0.01 -2.91 0.007 factor(gear)4 0.41 1.64 0.25 0.81 factor(gear)5 0.8 2.21 0.36 0.72 The use of background colors to draw attention to results is discouraged. The example in Table 10.8 uses background colors to denote the statistically signficant results. Notice how the colors may span multiple rows, which requires an additional strategy to assist row discrimination. When using background colors this way, horizontal borders are the best row discrimination aid. The primary criticism against background colors to highlight results is that background colors are either too subtle (as in the shades used for row discrimination) or not subtle enough. When a color is bold enough to draw attention to the result, it usually feels a bit like TYPING IN ALL CAPS. That is, a little jarring when done inappropriately. fit &lt;- lm(mpg ~ wt + factor(am) + hp + factor(gear), data = mtcars) dust(fit, label = &quot;background-result&quot;, caption = &quot;Statistically Significant Results Displayed Using Backgrounds. This practice is discouraged.&quot;) %&gt;% medley_model() %&gt;% medley_bw() %&gt;% sprinkle(# rows = quote(p.value &lt;= 0.05), # not yet supported rows = c(1, 2, 4), bg = palette[2]) %&gt;% sprinkle(border = &quot;bottom&quot;, border_color = &quot;gray&quot;) Table 10.8: Statistically Significant Results Displayed Using Backgrounds. This practice is discouraged. term estimate std.error statistic p.value (Intercept) 33.76 2.86 11.82 wt -2.8 1 -2.8 0.01 factor(am)1 1.69 1.84 0.92 0.37 hp -0.04 0.01 -2.91 0.007 factor(gear)4 0.41 1.64 0.25 0.81 factor(gear)5 0.8 2.21 0.36 0.72 10.4 Grouping It is sometimes beneficial to the user to visually discriminate groups of data from each other. This allows the user to more easily discern similarities within and differences between groups. The proper method for discriminating groups is to sort your data by group prior to generating the table (See Table 10.9 ) mtcars %&gt;% arrange(gear) %&gt;% dust(caption = &quot;Vehicular Data Sorted by Gear&quot;, label = &quot;basic-group&quot;) %&gt;% medley_bw() Table 10.9: Vehicular Data Sorted by Gear mpg cyl disp hp drat wt qsec vs am gear carb 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 14.3 8 360 245 3.21 3.57 15.84 0 0 3 4 16.4 8 275.8 180 3.07 4.07 17.4 0 0 3 3 17.3 8 275.8 180 3.07 3.73 17.6 0 0 3 3 15.2 8 275.8 180 3.07 3.78 18 0 0 3 3 10.4 8 472 205 2.93 5.25 17.98 0 0 3 4 10.4 8 460 215 3 5.424 17.82 0 0 3 4 14.7 8 440 230 3.23 5.345 17.42 0 0 3 4 21.5 4 120.1 97 3.7 2.465 20.01 1 0 3 1 15.5 8 318 150 2.76 3.52 16.87 0 0 3 2 15.2 8 304 150 3.15 3.435 17.3 0 0 3 2 13.3 8 350 245 3.73 3.84 15.41 0 0 3 4 19.2 8 400 175 3.08 3.845 17.05 0 0 3 2 21 6 160 110 3.9 2.62 16.46 0 1 4 4 21 6 160 110 3.9 2.875 17.02 0 1 4 4 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 24.4 4 146.7 62 3.69 3.19 20 1 0 4 2 22.8 4 140.8 95 3.92 3.15 22.9 1 0 4 2 19.2 6 167.6 123 3.92 3.44 18.3 1 0 4 4 17.8 6 167.6 123 3.92 3.44 18.9 1 0 4 4 32.4 4 78.7 66 4.08 2.2 19.47 1 1 4 1 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 33.9 4 71.1 65 4.22 1.835 19.9 1 1 4 1 27.3 4 79 66 4.08 1.935 18.9 1 1 4 1 21.4 4 121 109 4.11 2.78 18.6 1 1 4 2 26 4 120.3 91 4.43 2.14 16.7 0 1 5 2 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 15.8 8 351 264 4.22 3.17 14.5 0 1 5 4 19.7 6 145 175 3.62 2.77 15.5 0 1 5 6 15 8 301 335 3.54 3.57 14.6 0 1 5 8 If you wish to provide a little more assistance in discriminating groups, using alternating backgrounds as groups change may be a useful technique. This technique is illustrated in Table 10.10 and combined with borders to facilitate row discrimination. gear &lt;- which(mtcars$gear %in% c(3, 5)) not_gear &lt;- which(!mtcars$gear %in% c(3, 5)) mtcars %&gt;% arrange(gear) %&gt;% dust(caption = &quot;Vehicular Data Sorted by Gear with Background Toggling&quot;, label = &quot;toggle-background&quot;) %&gt;% medley_bw() %&gt;% sprinkle(# rows = quote(gear %in% c(3, 5)), # not yet supported rows = gear, bg = &quot;#DDDDDD&quot;, border = &quot;bottom&quot;, border_color = &quot;white&quot;) %&gt;% sprinkle(# rows = quote(!gear %in% c(3, 5)), # not yet supported rows = not_gear, bg = &quot;white&quot;, border = &quot;bottom&quot;, border_color = &quot;#DDDDDD&quot;) Table 10.10: Vehicular Data Sorted by Gear with Background Toggling mpg cyl disp hp drat wt qsec vs am gear carb 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 14.3 8 360 245 3.21 3.57 15.84 0 0 3 4 16.4 8 275.8 180 3.07 4.07 17.4 0 0 3 3 17.3 8 275.8 180 3.07 3.73 17.6 0 0 3 3 15.2 8 275.8 180 3.07 3.78 18 0 0 3 3 10.4 8 472 205 2.93 5.25 17.98 0 0 3 4 10.4 8 460 215 3 5.424 17.82 0 0 3 4 14.7 8 440 230 3.23 5.345 17.42 0 0 3 4 21.5 4 120.1 97 3.7 2.465 20.01 1 0 3 1 15.5 8 318 150 2.76 3.52 16.87 0 0 3 2 15.2 8 304 150 3.15 3.435 17.3 0 0 3 2 13.3 8 350 245 3.73 3.84 15.41 0 0 3 4 19.2 8 400 175 3.08 3.845 17.05 0 0 3 2 21 6 160 110 3.9 2.62 16.46 0 1 4 4 21 6 160 110 3.9 2.875 17.02 0 1 4 4 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 24.4 4 146.7 62 3.69 3.19 20 1 0 4 2 22.8 4 140.8 95 3.92 3.15 22.9 1 0 4 2 19.2 6 167.6 123 3.92 3.44 18.3 1 0 4 4 17.8 6 167.6 123 3.92 3.44 18.9 1 0 4 4 32.4 4 78.7 66 4.08 2.2 19.47 1 1 4 1 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 33.9 4 71.1 65 4.22 1.835 19.9 1 1 4 1 27.3 4 79 66 4.08 1.935 18.9 1 1 4 1 21.4 4 121 109 4.11 2.78 18.6 1 1 4 2 26 4 120.3 91 4.43 2.14 16.7 0 1 5 2 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 15.8 8 351 264 4.22 3.17 14.5 0 1 5 4 19.7 6 145 175 3.62 2.77 15.5 0 1 5 6 15 8 301 335 3.54 3.57 14.6 0 1 5 8 In some settings, particularly within spreadsheets, it is not uncommon to see groups discriminated by various background colors. An example of this behavior is shown in Table 10.11. This technique ought to be avoided as it requires the reader to remember the association of each color while trying to discern patterns and conclusions from the table. Some might say that I’ve presented an unfair comparison here, and that if I were to sort the table prior to assigning the background colors, it would not be as challenging for the reader. However, if the data have been sorted by group, there is no need for multiple background colors; instead, the alternating backgrounds used in Table 10.10 are sufficient and do not add the difficulty of remember what the various colors mean. gear3 &lt;- which(mtcars$gear %in% 3) gear4 &lt;- which(mtcars$gear %in% 4) gear5 &lt;- which(mtcars$gear %in% 5) mtcars %&gt;% dust(caption = &quot;Vehicular Data Sorted by Gear with Background Toggling&quot;, label = &quot;background-discriminate&quot;, keep_rownames = TRUE) %&gt;% medley_bw() %&gt;% sprinkle(# rows = quote(gear == 3), # not yet supported rows = gear3, bg = palette[2]) %&gt;% sprinkle(# rows = quote(gear == 4), # not yet supported rows = gear4, bg = palette[5]) %&gt;% sprinkle(# rows = quote(gear == 5), # not yet supported rows = gear5, bg = palette[8]) Table 10.11: Vehicular Data Sorted by Gear with Background Toggling .rownames mpg cyl disp hp drat wt qsec vs am gear carb Mazda RX4 21 6 160 110 3.9 2.62 16.46 0 1 4 4 Mazda RX4 Wag 21 6 160 110 3.9 2.875 17.02 0 1 4 4 Datsun 710 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 Hornet Sportabout 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 Valiant 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 Duster 360 14.3 8 360 245 3.21 3.57 15.84 0 0 3 4 Merc 240D 24.4 4 146.7 62 3.69 3.19 20 1 0 4 2 Merc 230 22.8 4 140.8 95 3.92 3.15 22.9 1 0 4 2 Merc 280 19.2 6 167.6 123 3.92 3.44 18.3 1 0 4 4 Merc 280C 17.8 6 167.6 123 3.92 3.44 18.9 1 0 4 4 Merc 450SE 16.4 8 275.8 180 3.07 4.07 17.4 0 0 3 3 Merc 450SL 17.3 8 275.8 180 3.07 3.73 17.6 0 0 3 3 Merc 450SLC 15.2 8 275.8 180 3.07 3.78 18 0 0 3 3 Cadillac Fleetwood 10.4 8 472 205 2.93 5.25 17.98 0 0 3 4 Lincoln Continental 10.4 8 460 215 3 5.424 17.82 0 0 3 4 Chrysler Imperial 14.7 8 440 230 3.23 5.345 17.42 0 0 3 4 Fiat 128 32.4 4 78.7 66 4.08 2.2 19.47 1 1 4 1 Honda Civic 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 Toyota Corolla 33.9 4 71.1 65 4.22 1.835 19.9 1 1 4 1 Toyota Corona 21.5 4 120.1 97 3.7 2.465 20.01 1 0 3 1 Dodge Challenger 15.5 8 318 150 2.76 3.52 16.87 0 0 3 2 AMC Javelin 15.2 8 304 150 3.15 3.435 17.3 0 0 3 2 Camaro Z28 13.3 8 350 245 3.73 3.84 15.41 0 0 3 4 Pontiac Firebird 19.2 8 400 175 3.08 3.845 17.05 0 0 3 2 Fiat X1-9 27.3 4 79 66 4.08 1.935 18.9 1 1 4 1 Porsche 914-2 26 4 120.3 91 4.43 2.14 16.7 0 1 5 2 Lotus Europa 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 Ford Pantera L 15.8 8 351 264 4.22 3.17 14.5 0 1 5 4 Ferrari Dino 19.7 6 145 175 3.62 2.77 15.5 0 1 5 6 Maserati Bora 15 8 301 335 3.54 3.57 14.6 0 1 5 8 Volvo 142E 21.4 4 121 109 4.11 2.78 18.6 1 1 4 2 If background colors are to be used, they ought to be used to accent something meaningful about the data that cannot be displayed by a simple sort. Consider, for example, Table @ref{tab:group-sort-shade}, which groups the data by gear, sorts it within each group by mpg, and then applies a gradient background to the mpg column to give a visual depiction of the distribution of mpg within each group. gear3 &lt;- which(mtcars$gear %in% 3) gear4 &lt;- which(mtcars$gear %in% 4) gear5 &lt;- which(mtcars$gear %in% 5) mtcars %&gt;% arrange(gear, mpg) %&gt;% dust(caption = &quot;Vehicular Data Grouped by Gear and Sorted by MPG&quot;, label = &quot;group-sort-shade&quot;) %&gt;% medley_bw() %&gt;% sprinkle(# rows = quote(gear %in% c(3, 5)), #not yet supported rows = gear3, bg = &quot;#DDDDDD&quot;, border = &quot;bottom&quot;, border_color = &quot;white&quot;) %&gt;% sprinkle(# rows = quote(!gear %in% c(3, 5)), # not yet supported rows = gear4, bg = &quot;white&quot;, border = &quot;bottom&quot;, border_color = &quot;#DDDDDD&quot;) %&gt;% sprinkle(cols = &quot;mpg&quot;, gradient = &quot;bg&quot;, gradient_color = palette[c(3, 7)]) Table 10.12: Vehicular Data Grouped by Gear and Sorted by MPG mpg cyl disp hp drat wt qsec vs am gear carb 10.4 8 472 205 2.93 5.25 17.98 0 0 3 4 10.4 8 460 215 3 5.424 17.82 0 0 3 4 13.3 8 350 245 3.73 3.84 15.41 0 0 3 4 14.3 8 360 245 3.21 3.57 15.84 0 0 3 4 14.7 8 440 230 3.23 5.345 17.42 0 0 3 4 15.2 8 275.8 180 3.07 3.78 18 0 0 3 3 15.2 8 304 150 3.15 3.435 17.3 0 0 3 2 15.5 8 318 150 2.76 3.52 16.87 0 0 3 2 16.4 8 275.8 180 3.07 4.07 17.4 0 0 3 3 17.3 8 275.8 180 3.07 3.73 17.6 0 0 3 3 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 19.2 8 400 175 3.08 3.845 17.05 0 0 3 2 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 21.5 4 120.1 97 3.7 2.465 20.01 1 0 3 1 17.8 6 167.6 123 3.92 3.44 18.9 1 0 4 4 19.2 6 167.6 123 3.92 3.44 18.3 1 0 4 4 21 6 160 110 3.9 2.62 16.46 0 1 4 4 21 6 160 110 3.9 2.875 17.02 0 1 4 4 21.4 4 121 109 4.11 2.78 18.6 1 1 4 2 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 22.8 4 140.8 95 3.92 3.15 22.9 1 0 4 2 24.4 4 146.7 62 3.69 3.19 20 1 0 4 2 27.3 4 79 66 4.08 1.935 18.9 1 1 4 1 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 32.4 4 78.7 66 4.08 2.2 19.47 1 1 4 1 33.9 4 71.1 65 4.22 1.835 19.9 1 1 4 1 15 8 301 335 3.54 3.57 14.6 0 1 5 8 15.8 8 351 264 4.22 3.17 14.5 0 1 5 4 19.7 6 145 175 3.62 2.77 15.5 0 1 5 6 26 4 120.3 91 4.43 2.14 16.7 0 1 5 2 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 While Table 10.12 is a reasonable and effective use of shading and grouping together, it still doesn’t have anywhere the visual impact as something as simple as Figure 10.1 ggplot(data = mtcars, mapping = aes(x = factor(gear), y = mpg)) + geom_boxplot() Figure 10.1: Graphical visualizations are often a superior tool to tables to display complex concepts. 10.4.1 The Time-Ordered Background Exception In cases where data are to be displayed ordered by time, there may be an exception to using background colors in place of grouping. in particular, the background color may be used to distinguish the occurrence of some event over the passage of time. When making a table in this manner, it is still recommended to limit yourself to two colors, and to apply those colors to only once column. An example is provided in Table 10.13. library(survival) ovarian %&gt;% arrange(futime) %&gt;% dust(caption = &quot;Arrange a Table by Time and Using Background Colors to Identify Events&quot;, label = &quot;temporal-table&quot;) %&gt;% sprinkle(bg_pattern_by = &quot;rows&quot;) %&gt;% sprinkle(cols = &quot;fustat&quot;, discrete = &quot;bg&quot;, discrete_color = palette[c(3, 7)]) %&gt;% medley_bw() Table 10.13: Arrange a Table by Time and Using Background Colors to Identify Events futime fustat age resid.ds rx ecog.ps 59 1 72.3315 2 1 1 115 1 74.4932 2 1 1 156 1 66.4658 2 1 2 268 1 74.5041 2 1 2 329 1 43.137 2 1 1 353 1 63.2192 1 2 2 365 1 64.4247 2 2 1 377 0 58.3096 1 2 1 421 0 53.3644 2 2 1 431 1 50.3397 2 1 1 448 0 56.4301 1 1 2 464 1 56.937 2 2 2 475 1 59.8548 2 2 2 477 0 64.1753 2 1 1 563 1 55.1781 1 2 2 638 1 56.7562 1 1 2 744 0 50.1096 1 2 1 769 0 59.6301 2 2 2 770 0 57.0521 2 2 1 803 0 39.2712 1 1 1 855 0 43.1233 1 1 2 1040 0 38.8932 2 1 2 1106 0 44.6 1 1 1 1129 0 53.9068 1 2 1 1206 0 44.2055 2 2 1 1227 0 59.589 1 2 2 10.5 Sectioning Sectioning is similar to grouping, with the added feature of putting a much stronger visual barrier between groups. There are two variants of sectioning. The first involves a row barrier, the second involves a table barrier. 10.5.1 Row Barrier A row barrier is a visual obstruction within a table that takes up an entire row to indicate to the user that there is something different about the content that follows. An example is given in 10.14. At the time of this writing, pixiedust does not offer a mechanism for generating a table in this style, and so applying additional formatting, such as row stripes, etc, can require a great deal of code. gear_na &lt;- which(is.na(mtcars$gear)) split(mtcars, mtcars$gear) %&gt;% lapply(FUN = function(x) bind_rows(data.frame(mpg = x$gear[1]), x)) %&gt;% bind_rows() %&gt;% dust(caption = &quot;Table Sectioned with a Row Barrier&quot;, label = &quot;row-barrier&quot;) %&gt;% medley_bw() %&gt;% sprinkle(# rows = quote(is.na(gear)), # not yet supported rows = gear_na, cols = &quot;mpg&quot;, fn = quote(sprintf(&quot;Gear = %s&quot;, value))) %&gt;% sprinkle(rows = 1, merge = TRUE, halign = &quot;left&quot;, bg = &quot;#DDDDDD&quot;) %&gt;% sprinkle(rows = 17, merge = TRUE, halign = &quot;left&quot;, bg = &quot;#DDDDDD&quot;) %&gt;% sprinkle(rows = 30, merge = TRUE, halign = &quot;left&quot;, bg = &quot;#DDDDDD&quot;) Table 10.14: Table Sectioned with a Row Barrier mpg cyl disp hp drat wt qsec vs am gear carb 3 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 14.3 8 360 245 3.21 3.57 15.84 0 0 3 4 16.4 8 275.8 180 3.07 4.07 17.4 0 0 3 3 17.3 8 275.8 180 3.07 3.73 17.6 0 0 3 3 15.2 8 275.8 180 3.07 3.78 18 0 0 3 3 10.4 8 472 205 2.93 5.25 17.98 0 0 3 4 10.4 8 460 215 3 5.424 17.82 0 0 3 4 14.7 8 440 230 3.23 5.345 17.42 0 0 3 4 21.5 4 120.1 97 3.7 2.465 20.01 1 0 3 1 15.5 8 318 150 2.76 3.52 16.87 0 0 3 2 15.2 8 304 150 3.15 3.435 17.3 0 0 3 2 13.3 8 350 245 3.73 3.84 15.41 0 0 3 4 19.2 8 400 175 3.08 3.845 17.05 0 0 3 2 4 21 6 160 110 3.9 2.62 16.46 0 1 4 4 21 6 160 110 3.9 2.875 17.02 0 1 4 4 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 24.4 4 146.7 62 3.69 3.19 20 1 0 4 2 22.8 4 140.8 95 3.92 3.15 22.9 1 0 4 2 19.2 6 167.6 123 3.92 3.44 18.3 1 0 4 4 17.8 6 167.6 123 3.92 3.44 18.9 1 0 4 4 32.4 4 78.7 66 4.08 2.2 19.47 1 1 4 1 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 33.9 4 71.1 65 4.22 1.835 19.9 1 1 4 1 27.3 4 79 66 4.08 1.935 18.9 1 1 4 1 21.4 4 121 109 4.11 2.78 18.6 1 1 4 2 5 26 4 120.3 91 4.43 2.14 16.7 0 1 5 2 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 15.8 8 351 264 4.22 3.17 14.5 0 1 5 4 19.7 6 145 175 3.62 2.77 15.5 0 1 5 6 15 8 301 335 3.54 3.57 14.6 0 1 5 8 10.5.2 Table Barrier A table barrier separates groups by putting each group in a distinct table. For example: split(mtcars, mtcars$gear) %&gt;% dust(caption = &quot;Table Sectioned with a Row Barrier&quot;, label = &quot;row-barrier&quot;) %&gt;% sprinkle(bg_pattern_by = &quot;rows&quot;) %&gt;% pixieply(medley_bw) Table 10.14: Table Sectioned with a Row Barrier mpg cyl disp hp drat wt qsec vs am gear carb 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 14.3 8 360 245 3.21 3.57 15.84 0 0 3 4 16.4 8 275.8 180 3.07 4.07 17.4 0 0 3 3 17.3 8 275.8 180 3.07 3.73 17.6 0 0 3 3 15.2 8 275.8 180 3.07 3.78 18 0 0 3 3 10.4 8 472 205 2.93 5.25 17.98 0 0 3 4 10.4 8 460 215 3 5.424 17.82 0 0 3 4 14.7 8 440 230 3.23 5.345 17.42 0 0 3 4 21.5 4 120.1 97 3.7 2.465 20.01 1 0 3 1 15.5 8 318 150 2.76 3.52 16.87 0 0 3 2 15.2 8 304 150 3.15 3.435 17.3 0 0 3 2 13.3 8 350 245 3.73 3.84 15.41 0 0 3 4 19.2 8 400 175 3.08 3.845 17.05 0 0 3 2 Table 10.14: Table Sectioned with a Row Barrier mpg cyl disp hp drat wt qsec vs am gear carb 21 6 160 110 3.9 2.62 16.46 0 1 4 4 21 6 160 110 3.9 2.875 17.02 0 1 4 4 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 24.4 4 146.7 62 3.69 3.19 20 1 0 4 2 22.8 4 140.8 95 3.92 3.15 22.9 1 0 4 2 19.2 6 167.6 123 3.92 3.44 18.3 1 0 4 4 17.8 6 167.6 123 3.92 3.44 18.9 1 0 4 4 32.4 4 78.7 66 4.08 2.2 19.47 1 1 4 1 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 33.9 4 71.1 65 4.22 1.835 19.9 1 1 4 1 27.3 4 79 66 4.08 1.935 18.9 1 1 4 1 21.4 4 121 109 4.11 2.78 18.6 1 1 4 2 Table 10.14: Table Sectioned with a Row Barrier mpg cyl disp hp drat wt qsec vs am gear carb 26 4 120.3 91 4.43 2.14 16.7 0 1 5 2 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 15.8 8 351 264 4.22 3.17 14.5 0 1 5 4 19.7 6 145 175 3.62 2.77 15.5 0 1 5 6 15 8 301 335 3.54 3.57 14.6 0 1 5 8 The tools in pixiedust permit more flexible formatting in this style of division, and can even be used to make a table similar in style to that of Table 10.12. split(mtcars, mtcars$gear) %&gt;% dust(caption = &quot;Table Sectioned with a Row Barrier&quot;, label = &quot;row-barrier&quot;) %&gt;% sprinkle(bg_pattern_by = &quot;rows&quot;) %&gt;% sprinkle(cols = &quot;mpg&quot;, gradient = &quot;bg&quot;, gradient_color = palette[c(2, 8)], gradient_cut = quantile(mtcars$mpg, probs = seq(0, 1, length.out = 10))) %&gt;% pixieply(medley_bw) Table 10.14: Table Sectioned with a Row Barrier mpg cyl disp hp drat wt qsec vs am gear carb 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 18.7 8 360 175 3.15 3.44 17.02 0 0 3 2 18.1 6 225 105 2.76 3.46 20.22 1 0 3 1 14.3 8 360 245 3.21 3.57 15.84 0 0 3 4 16.4 8 275.8 180 3.07 4.07 17.4 0 0 3 3 17.3 8 275.8 180 3.07 3.73 17.6 0 0 3 3 15.2 8 275.8 180 3.07 3.78 18 0 0 3 3 10.4 8 472 205 2.93 5.25 17.98 0 0 3 4 10.4 8 460 215 3 5.424 17.82 0 0 3 4 14.7 8 440 230 3.23 5.345 17.42 0 0 3 4 21.5 4 120.1 97 3.7 2.465 20.01 1 0 3 1 15.5 8 318 150 2.76 3.52 16.87 0 0 3 2 15.2 8 304 150 3.15 3.435 17.3 0 0 3 2 13.3 8 350 245 3.73 3.84 15.41 0 0 3 4 19.2 8 400 175 3.08 3.845 17.05 0 0 3 2 Table 10.14: Table Sectioned with a Row Barrier mpg cyl disp hp drat wt qsec vs am gear carb 21 6 160 110 3.9 2.62 16.46 0 1 4 4 21 6 160 110 3.9 2.875 17.02 0 1 4 4 22.8 4 108 93 3.85 2.32 18.61 1 1 4 1 24.4 4 146.7 62 3.69 3.19 20 1 0 4 2 22.8 4 140.8 95 3.92 3.15 22.9 1 0 4 2 19.2 6 167.6 123 3.92 3.44 18.3 1 0 4 4 17.8 6 167.6 123 3.92 3.44 18.9 1 0 4 4 32.4 4 78.7 66 4.08 2.2 19.47 1 1 4 1 30.4 4 75.7 52 4.93 1.615 18.52 1 1 4 2 33.9 4 71.1 65 4.22 1.835 19.9 1 1 4 1 27.3 4 79 66 4.08 1.935 18.9 1 1 4 1 21.4 4 121 109 4.11 2.78 18.6 1 1 4 2 Table 10.14: Table Sectioned with a Row Barrier mpg cyl disp hp drat wt qsec vs am gear carb 26 4 120.3 91 4.43 2.14 16.7 0 1 5 2 30.4 4 95.1 113 3.77 1.513 16.9 1 1 5 2 15.8 8 351 264 4.22 3.17 14.5 0 1 5 4 19.7 6 145 175 3.62 2.77 15.5 0 1 5 6 15 8 301 335 3.54 3.57 14.6 0 1 5 8 "]
]
